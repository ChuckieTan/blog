---
date: 2022/03/04 10:26
updated: 2022/03/04 10:35
tags:
  - 数据库
---

## 并发一致性问题
在并发状态下，如果完全不考虑隔离性，会出现特殊的读类型：

### 脏读（Dirty Read）

A 事务读取 B 事务尚未提交的数据，此时如果 B 事务发生错误并执行回滚操作，那么 A 事务读取到的数据就是脏数据。就好像原本的数据比较干净、纯粹，此时由于 B 事务更改了它，这个数据变得不再纯粹。这个时候 A 事务立即读取了这个脏数据，但事务 B 良心发现，又用回滚把数据恢复成原来干净、纯粹的样子，而事务 A 却什么都不知道，最终结果就是事务 A 读取了此次的脏数据，称为脏读。

以转账和取款操作为例：

| 发生时间 | 转账事务                       | 取款事务                              |
| -------- | ------------------------------ | ------------------------------------- |
| 1        |                                | 开始事务                              |
| 2        | 开始事务                       |                                       |
| 3        |                                | 查询余额为 200 元                     |
| 4        |                                | 取款 100 元，更改余额为 100 元        |
| 5        | 查询余额为 100 元（产生脏读）  |                                       |
| 6        |                                | 发生错误，回滚操作，余额更改为 100 元 |
| 7        | 转入 200 元，余额变更为 300 元 |                                       |
| 8        | 提交事务                       |                                       |
| 9        |                                | 提交事务                                      |

按照正确的逻辑，事务结束时余额应该为 400 元。

### 不可重复读（Nonrepeatable Read）

在同一个事务中，某查询操作在一个时间读取某一行数据和之后一个时间读取该行数据，发现数据已经发生修改（针对 `update` 操作）。

以转账和查询操作为例：

| 发生时间 | 查询事务        | 转账事务                    |
| -------- | --------------- | --------------------------- |
| 1        | 开始事务        |                             |
| 2        | 查询余额为 100  |                             |
| 3        |                 | 开始事务                    |
| 4        |                 | 存入 100 元，余额变为 200 元 |
| 5        | 其他操作        |                             |
| 6        |                 | 提交事务                    |
| 7        | 查询余额为 200 元 |                             |
| 8        | 提交事务        |                             |

按照正确逻辑，查询事务两次查询到的余额应该一致，但两次查询到的余额不一致，发生了不可重复读。

### 幻读（Phantom Read）

事务 A 在执行读取操作，需要两次统计数据的总量，前一次查询数据总量后，此时事务 B 执行了新增数据的操作并提交后，这个时候事务 A 读取的数据总量和之前统计的不一样，就像产生了幻觉一样，平白无故的多了几条数据，成为幻读（针对 `insert` 和 `delete` 操作）。

| 发生时间 | 查询事务              | 插入事务        |
| -------- | --------------------- | --------------- |
| 1        | 开始事务              |                 |
| 2        | 查询数据总量为 100 条 |                 |
| 3        |                       | 开始事务        |
| 4        |                       | 插入 100 条数据 |
| 5        | 其他操作              |                 |
| 6        |                       | 提交事务        |
| 7        | 查询数据总量为 200 条 |                 |
| 8        | 提交事务              |                 |

按照正确逻辑，查询事务两次查询到的数据总量应该一致。

### 不可重复读和脏读的区别

不可重复读和脏读的区别为：脏读读取的是另一个事务未提交的数据，而不可重复读读取的是另一个事务已提交的数据。

### 不可重复读和幻读的区别

1. 不可重复读是读取了其他事务更改的数据，针对 `update` 操作

解决：使用行级锁，锁定该行，事务 A 多次读取操作完成后才释放该锁，这个时候才允许其他事务更改刚才的数据。

2. 幻读是读取了其他事务新增的数据，针对 `insert` 和 `delete` 操作

解决：使用表级锁，锁定整张表，事务 A 多次读取数据总量之后才释放该锁，这个时候才允许其他事务新增数据。

## 隔离级别

在实际使用中，完整的隔离性会严重影响数据库的并发性能，所以为了协调性能和隔离性，一般的数据库有着不同的隔离级别。

数据库事务的隔离级别有 4 个，由低到高依次为 `读未提交（Read Uncommitted）` 、 `读提交（Read Committed）` 、 `可重复读（Repeatable Read）` 、 `可串行化（Serializable）`，这四个级别可以逐个解决脏读、不可重复读、幻读这几类问题。

| 隔离级别         | 脏读   | 不可重复读 | 幻读   |
| ---------------- | ------ | ---------- | ------ |
| Read Uncommitted | 可能 | 可能     | 可能 |
| Read Committed   | 不可能   | 可能     | 可能 |
| Repeatable Read  | 不可能   | 不可能       | 可能 |
| Serializable     | 不可能   | 不可能       | 不可能   |

大部分数据库默认使用的是读提交（Read Committed）模式。

MySQL的可重复读模式可以一定程度上避免了幻读，该特性是采用间隙锁（gap lock）来实现的。

串行化每次读都需要获得表级共享锁，读写相互都会阻塞，其对资源的开销大，对并发支持不好，只在某些场景下使用。