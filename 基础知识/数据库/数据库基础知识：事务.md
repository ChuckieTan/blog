---
date: 2022/03/04 08:27
updated: 2022/03/04 10:22
tags:
  - 数据库
  - 事务
---

## 事务的概念

事务是并发控制的单位，是我们自己定义的一个操作序列。这些操作要么都做，要么都不做，是一个分
割的工作单位。通过事务，能将逻辑相关的一组操作绑定在一起，以便服务器保持数据的完整性。

如：银行转账，A 用户账户扣完钱后出现异常，导致 B 用户未能收到钱，此时不能正常开启事务，数据库中
数据不会发现变化，AB 账号余额不变。

事务通常是以 BEGIN TRANSACTION 开始，以 COMMIT 或 ROLLBACK 结束。

COMMIT 表示提交，即提交事务的所有操作。具体地说就是将事务中所有对数据库的更新写回到磁盘上的物理数据库中去，事务正常结束。

ROLLBACK 表示回滚，即在事务运行的过程中发生了某种故障，事务不能继续进行，系统将事务中对数据库的所有以完成的操作全部撤消，滚回到事务开始的状态。

举个例子：

```SQL
start transaction;
  update account set money=money-100 where name = '张三';
  update account set money=money+100 where name = '李四';
commit;
```

事务的体现：这两个 SQL 要么全部成功，要么全部失败。

## 事务的四大特性（ACID 特性）

### 1、原子性（Atomicity）

原子性是指事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败。比如在同一个事务中的 SQL 语句，要么全部执行成功，要么全部执行失败。

### 2、一致性（Consistency）

官网上事务一致性的概念是：事务必须使数据库从一个一致性状态变换到另外一个一致性状态。

换一种方式理解就是：事务按照预期生效，数据的状态是预期的状态。

拿转账来说，假设用户 A 和用户 B 两者的钱加起来一共是 5000，那么不管 A 和 B 之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是 5000，这就是事务的一致性。

一致性可以用约束或者触发器来保证。

### 3、隔离性（Isolation）

事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。

隔离性在并发状态下很难保证，会出现很多并发一致性的问题，其解决方案也会对数据库的并发性能有一定的影响。

常见的隔离级别一般有：一般有 `read_uncommit`，`read_commit`，`read_repeatable`，`Serializable 串行化访问` 四种隔离级别。

### 4、持久性（Durability）

持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。

这个用于解决数据库的非正常退出导致的数据损坏问题。

例如我们在操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。

## 数据库 ACID 的体现

### 1、原子性

原子性说的是数据要么一起成功，要么一起失败，那么就有两种情况：事务提交（commit）和事务回滚（rollback）。回滚一般用回滚日志实现，反向执行日志中的操作。

我们先看下事务正常提交的情况，下面我们在数据库模拟张三给李四转账成功的场景：

```SQL
MariaDB [user]> select * from account;
+----+--------+-------+
| id | name   | money |
+----+--------+-------+
|  1 | 张三   |  1000 |
|  2 | 李四   |     0 |
+----+--------+-------+
-- 开启事务
MariaDB [user]> start transaction;
-- 张三扣减金额
MariaDB [user]> update account set money=money-100 where name = '张三';
-- 李四增加金额
MariaDB [user]> update account set money=money+100 where name = '李四';
-- 提交事务
MariaDB [user]> commit;

MariaDB [user]> select * from account;
+----+--------+-------+
| id | name   | money |
+----+--------+-------+
|  1 | 张三   |   900 |
|  2 | 李四   |   100 |
+----+--------+-------+
```

如果事务回滚的话：

```SQL
MariaDB [user]> select * from account;
+----+--------+-------+
| id | name   | money |
+----+--------+-------+
|  1 | 张三   |   900 |
|  2 | 李四   |   100 |
+----+--------+-------+

MariaDB [user]> start transaction;

MariaDB [user]> update account set money=money-100 where name = '张三';

MariaDB [user]> update account set money=money+100 where name = '李四';

MariaDB [user]> rollback;

MariaDB [user]> select * from account;
+----+--------+-------+
| id | name   | money |
+----+--------+-------+
|  1 | 张三   |   900 |
|  2 | 李四   |   100 |
+----+--------+-------+
```

可以看到，两个操作都失败了，数据并没有发生改变，这就确保了事务的原子性。

### 2、一致性

一致性主要说明的是事务的前后，数据库中的数据的状态要确保一致。

事务提交成功，那么张三账户上的余额是 900 元，李四账户上的余额是 100 元。

事务提交失败，那么张三和李四的账户的金额不变。

这说明现在在数据库的事务的控制下，确保了数据的一致性。

### 3、隔离性

隔离性的体现，多个并发事务之间是隔离的，不同的隔离级别有不同的隔离力度。

张三给李四转账，如果事务没有提交的话，那么在其他事务中并不能查看当前事务未提交的数据。

当前事务：

```SQL
MariaDB [user]> start transaction;

MariaDB [user]> update account set money=money-100 where name = '张三';

MariaDB [user]> update account set money=money+100 where name = '李四';
```

另一个事务：

```SQL
select * from account;
+----+--------+-------+
| id | name   | money |
+----+--------+-------+
|  1 | 张三   |   900 |
|  2 | 李四   |   100 |
+----+--------+-------+
```

可以看到，另一个事务并没有查看到当前还未提交的数据。

### 4、持久性

持久性的体现就是数据一旦 commit 之后，那么对于数据的改变就是永久的。我们 commit 之后，张三的账户就永久减少了 100 元，李四的账户就永久增加了 100 元，即使在 commit 后具体的数据只写入到内存缓存中并异常退出，再次打开数据库数据也会持久化到磁盘中。持久性一般由 Double Write 和 Redo Log 实现。
